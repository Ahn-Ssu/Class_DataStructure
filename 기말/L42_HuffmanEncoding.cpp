/**
 * <Huffman tree>
 *      예제 1 
 *      : 서로 다른 길이의 sorted list들을 two-way merge를 적용하여 
 *        한 개의 sorted list를 생성할 때, 최적의 merge 순서는?
 * 
 *      //two-way merge : 두 개를 하나로 합치는 방식. 
 *      // 서로 다른 길이에 주목 
 *      // Q. 어떻게 결합 순서를 짤 것인가?? 
 * 
 *      // 효율에 관한 문제 
 * 
 *      // 각 list를 처음부터 끝까지 읽어야함
 *      //*두 개의 list를 합치는 과정은 각각의 원소의 합만큼 읽어야함
 * 
 *      
 *      { 4, 6, 12, 21 } 
 * 
 *         i) 토너먼트 하듯이 각각 더하기
 *              4 + 6 = 10 
 *              12 + 21 = 33
 *              10 + 33 = 43 
 * 
 *             > 총 걸리는 시간 86
 * 
 *         ii) Huffman tree 사용
 *              4 + 6 = 10 
 *              10 + 12 = 22
 *              22 + 21 = 34
 *      
 *             > 총 걸리는 시간 75 
 * 
 * < Huffman tree 생성 방법 >
 *      - 현재의 list 들 중에서, cost가 "가장 작은" 2개를 선택하여 결합시킨다.
 *      - *가장 최적, 이게 제일 최소 비교 이다. 
 * 
 *      예제) 길이가 각각 { 4, 6, 12, 21 } 인 4개의 list를 merge하는 방법 
 *              4 + 6 = 10
 *              10 + 12 = 22
 *              22 + 21 = 43 
 * 
 *              총 걸리는 시간  '75'
 * 
 *      예제) 길이가 각각 { 2, 4, 5, 7, 9, 12 } 인 6개의 list를 merge하는 방법
 *              2 + 4 = 6
 *              6 + 5 = 11
 *              11 + 7 = 18
 *              18 + 9 = 27
 *              27 + 12 = 39 
 * 
 *             >총 걸리는 시간 '101'
 *             >!!틀렸음!! 
 * 
 *              2 + 4 = 6
 *              6 + 5 = 11 
 *             "7 + 9 = 16"
 *             "11 + 12 = 23" 
 *              16 + 23 = 39
 * 
 *             >총 걸리는 시간 '95'
 * 
 * 
 *   
 * <Huffman Encoding>
 *      : 정보의 종류별로 빈도(frequency)가 알려져 있을 때 효율적인 Encoding 방법 -> Huffman tree
 * 
 *      예제) decode tree를 이용한 정보의 표현 
 *              4가지 종류의 정보 { A, B, C, D } 를 표현하는 방법 
 *
 *              A = 00
 *              B = 01 
 *              C = 10 
 *              D = 11 
 * 
 *          // 빈도가 일정한 경우에 complete tree  생성 
 * 
 *          //정보 부호화 -> 인코딩
 *          //부호화 해독 -> 디코딩 
 * 
 * 
 *       예제)
 *        다음과 같이 6가지 정보에 대하여 상대적인 빈도가 주어졌을 때, 
 *        이에 대한 최적의 encoding 방법을 제시
 * 
 *        A(7), B(12), C(3), D(5), E(9), F(2)   // 알려져있는(통계의) 빈도수 
 * 
 *        방법) decode tree로서 huffman tree 생성 
 * 
 *          C + F = 5 
 *          5 + D = 10 
 *          A + E = 16 
 *          10 + B = 22
 *          16 + 22 = 38 
 * 
 *          왼쪽 branch 는 0 오른쪽 branch는 1 
 * 
 *                  *
 *                  01
 *                 0101
 *               01010101
 * 
 *          -> 자주 나타나는 것을 짧은 것으로 부호화 하고 가끔 나타나는 것을 긴것을 쓰면 평균보다 유리할 것이다
 *          -> 이것이 호프만 트리의 관점! 
 * 
 *          A = 10
 *          B = 01
 *          C = 0001
 *          D = 001
 *          E = 11
 *          F = 0000 
 * 
 * 
 *        Q. BEBBEAAC를 표현 할 때, 각각을 3 bits로 표현하는 방식에 비해 효율적인가? 
 *              
 *          -----HUFFMAN------
 *          A = 10
 *          B = 01
 *          C = 0001
 *          D = 001
 *          E = 11
 *          F = 0000 
 * 
 *          ------Basic--------
 *          A = 000
 *          B = 001
 *          C = 010
 *          D = 011
 *          E = 100
 *          F = 101 
 * 
 * 
 * 
 *      011101011110100001 (H:18Bits)
 *       vs 
 *      001100001001100000000000010 (B:24Bits)
 * 
 *      균일하게 코딩하는 것보다 빈도를 반영하여 코드화 하고,  
 *      실제 데이터가 그 빈도에 맞추어서 발생을 했다면!
 *      !호프만 코딩이 유리하다! 
 *
 *       
 * 
 *  - Merge sort  할때 데이터를 읽는 횟수를 줄이는 최적의 방법
 *  - 호프만코딩과 같은 정보의 종류를 상대적 빈도를 반영하여 하는 코딩방식
 */